#! /usr/bin/env ruby

def main
  results = {}

  max_count = 0

  if ARGV.size > 0
    authors = ARGV
  else
    authors = get_authors
  end

  authors.each do |author|
    lines = `git log --author='#{author}'`
    time_lines = lines.split("\n").select {|l| l =~ /^Date:/}
    times = time_lines.map {|l| l.split(' ').select {|piece| piece =~ /\d\d\:\d\d\:\d\d/} }.flatten
    groups = times.group_by do |l|
      get_time_segment(l)
    end

    segments = groups.keys.sort

    results[author] = {}
    segments.each do |g|
      count = groups[g].size
      results[author][g] = count
      max_count = count if count > max_count
    end
  end

  pivoted = {}
  results.each do |author, hours|
    hours.each do |hour, times|
      pivoted[hour] ||= {}
      pivoted[hour][author] = times
    end
  end

  segments = pivoted.keys.sort.compact

  print_author_key authors
  scaled_max = 30.0
  scale = scaled_max / (max_count + 1)
  col_width = max_count.to_s.length + 1
  col_width = 3 if col_width < 3
  empty_cell = ' ' * col_width

  plot = 1.upto(segments.size).map do |x|
    1.upto(scaled_max).map do |y|
      ' '
    end
  end

  segments.each_with_index do |hour, i |
    pivoted[hour].each do |author, count|
      y = count * scale
      if (plot[i][y] != ' ')
        direction = 15 <=> y
        while plot[i][y] != ' '
          y = y + direction
        end
      end
      plot[i][y] = get_point(author)
    end
  end

  graph = 1.upto(scaled_max).map do |y|
    line = 1.upto(segments.count).map do |x|
      plot[x-1][y-1]
    end

    "% #{col_width}d" % (y/scale) + ' ' + line.join(' ' * (col_width -1) )
  end

  graph.reverse.each {|line| puts line}

  axis = ''
  counts = ['   '] * authors.length

  pivoted.keys.sort.each do |segment|
    if segment[3..4] == '00'
      axis += colorize(segment[0..1],32)
    else
      axis += colorize(segment[3..4], 33)
    end
    axis += (' ' * (col_width -2))

    authors = pivoted[segment].keys.sort_by do |author|
      pivoted[segment][author]
    end.reverse

    0.upto(authors.size - 1) do |i|
      counts[i] += colorize("% #{col_width}d" % pivoted[segment][authors[i]], get_color(authors[i]))
    end
    authors.size.upto(counts.length - 1) do |i|
      counts[i] +=empty_cell 
    end
  end

  puts empty_cell + ' ' + axis
  puts empty_cell + ' ' + ('-' * (segments.length * col_width))
  puts ' ' +  counts.join("\n ")

end

def get_authors
  all = `git shortlog`.split("\n").select {|line| line =~ /\(\d+\):$/}
  parsed = all.map do |line|
    pos = line.rindex('(')
    { 
      :name => line[0..(pos - 2)],
      :count => line[(pos +1)...-2].to_i
    }
  end 
  sorted = parsed.sort_by {|a| -a[:count]}
  top_5 = sorted[0..4]
  @authors = top_5.map {|a| a[:name]}
end

def print_author_key authors
  authors.each {|author| puts colorize(author,  get_color( author )) }
end

def get_time_segment time
  minutes_per_segment = 30
  pieces = time.split(':')
  hour = pieces.first
  minute = (pieces[1].to_i / minutes_per_segment).to_i * minutes_per_segment

  "#{hour}:#{'%02d' % minute}"
end

def get_color author
  colors = [31,32,33,34,35,36]
  index = @authors.index(author)
  color = colors[index % colors.length]
end

def get_point author
  colorize("#", get_color( author ))
end

def colorize(text, color_code)
  "\e[#{color_code}m#{text}\e[0m"
end

main
